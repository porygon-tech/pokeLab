# -*- coding: utf-8 -*-
"""rator.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Iz5HxJ10pVHrPZKxHNbPCxxmm9Durd90

# Initialize
"""

#https://www.smogon.com/stats/
import pandas as pd
import numpy as np
import requests
import re


'''
dat.keys()
dat['Moves']
dat['Checks and Counters']
dat['Abilities']
dat['Teammates']
dat['usage']
dat['Items']
dat['Raw count']
dat['Spreads']
dat['Happiness']
dat['Viability Ceiling']
'''

import ast
r = requests.get('https://www.smogon.com/dex/sv/moves/#!')


#--------------------------------------------------------------
d = re.findall(r"\"moves\":\[(.+)\],\"types\":", r.text)[0]
#dl=re.findall(r"{\"name\":.+\"\]}",d)[0]
db_moves = list(ast.literal_eval(d))
keynames_moves = [i['name'].lower().replace(' ', '').replace('-', '') for i in db_moves]
dict_moves = dict(zip(keynames_moves,db_moves))

#--------------------------------------------------------------
d = re.findall(r"}\]\,\"abilities\":\[(.+)\],\"moveflags\":", r.text)[0]
db_abilities = list(ast.literal_eval(d))
keynames_abilities = [i['name'].lower().replace(' ', '').replace('-', '') for i in db_abilities]
dict_abilities = dict(zip(keynames_abilities,db_abilities))

#--------------------------------------------------------------
d = re.findall(r"}\],\"items\":\[(.+)\]}\]\],\"showEditorUI\"", r.text)[0]
db_items = list(ast.literal_eval(d))
keynames_items = [i['name'].lower().replace(' ', '').replace('-', '') for i in db_items]
dict_items = dict(zip(keynames_items,db_items))



def choosefrom(probDict,n=1):
    probs=np.array(list(probDict.values()))
    probs = probs/probs.sum()
    return np.array(list(probDict.keys()))[np.random.choice(np.arange(len(probDict)),p=probs,size=n, replace=False)]

def bestof(probDict, n=1):
    #max(spreads, key=spreads.get)
    dict_sorted = dict(sorted(probDict.items(), key=lambda item: item[1]))
    return list(dict_sorted.keys())[-n:]

statNames = ['HP','Atk','Def','SpA','SpD','Spe']

def get_years():
  html_text = requests.get('https://www.smogon.com/stats/', timeout=2).text
  years = [i.replace('\"', '') for i in re.findall(r"\"\S+\-\S+/\"", html_text)]
  return years

def get_metas(year=None):
  if not year:
    year = get_years()[-1]

  url = 'https://www.smogon.com/stats/' + year + 'chaos/'
  html_text = requests.get(url, timeout=2).text
  metas = [i.replace('\"', '') for i in re.findall(r"\"\S+\.json\"", html_text)]
  return metas

def get_meta_json(meta, year=None, to_pandas=True):
  if not year:
    year = get_years()[-1]

  url = 'https://www.smogon.com/stats/' + year + 'chaos/' + meta
  print('fetching '+ url)
  r = requests.get(url)
  j = r.json()
  if to_pandas:
    db = pd.DataFrame.from_dict(j)
    mon_db = db.drop(['team type', 'cutoff', 'cutoff deviation', 'metagame', 'number of battles'])
    return mon_db
  else:
    return j


def filterbest(mon_db, competition_level = 0.01):
  noncompeting = list(map(lambda dic: dic['usage'] < competition_level, mon_db.data))
  blacklist = mon_db.index*noncompeting
  blacklist = blacklist[np.where(blacklist != '')]
  top = mon_db.drop(blacklist)
  return top

def filterbymove(mon_db,  movename = 'ancientpower', UsageThreshold = 0.1):
  return mon_db[list(map(lambda dic: (dic['Moves'][movename] / sum(dic['Moves'].values()) > UsageThreshold) if movename in dic['Moves'].keys() else False , mon_3.data))]



def makeF2(top):
  n=len(top)
  f2 = np.zeros((n,n))
  friendMine = list(map(lambda dic: dic['Teammates'], top.data))
  fA = dict(zip(top.index,friendMine))
  for a in range(n):
    for b in range(n):
      if top.index[a] in fA:
        if top.index[b] in fA[top.index[a]]:
          f2[a,b] = fA[top.index[a]][top.index[b]]

  f2 /= f2.sum()
  return f2

def makeF3(f2):
  f2e = f2[...,np.newaxis]
  f3 = f2e  * np.swapaxes(f2e, 0,2)  * np.swapaxes(f2e, 1,2)
  f3 /= f3.sum()
  return f3

def makeF4(f3):
  f3e = f3[...,np.newaxis]
  f4 = f3e  * np.swapaxes(f3e, 0,3) * np.swapaxes(f3e, 1,3) * np.swapaxes(f3e, 2,3)
  f4 /= f4.sum()
  return f4


def recommendTeammates(poke, n=5, random=True):
  if random:   
    return list(choosefrom(poke.data['Teammates'],n))
  else:
    return bestof(poke.data['Teammates'],n)

def instanceOfPoke(poke):
  global statNames
  dat = poke.data
  moves = choosefrom(dat['Moves'],4)
  ability = choosefrom(dat['Abilities'])[0]
  item = choosefrom(dat['Items'])[0]
  spread = choosefrom(dat['Spreads'])[0]
  nature = re.findall(r"(\S+):", spread)[0]
  evs = dict(zip(statNames, list(map(int, re.findall(r"\d+", spread)))))
  evtext = ''
  for ev in evs.keys(): 
    if evs[ev] > 0: 
      evtext += (str(evs[ev]) + ' ' + ev + ' / ')
  string = ''
  string += (poke.name + ' @ ' + dict_items[item]['name'] + '\n')
  string += ('Ability: ' + dict_abilities[ability]['name'] + '\n')
  string += ('EVs: ' + evtext[:-1] + '\n')
  string += (nature + ' Nature' + '\n')
  for i in moves: string += ('- ' + dict_moves[i]['name'] + '\n')
  #string += (poke.name + ' @ ' + item + '\n')
  #string += ('Ability: ' + ability + '\n')
  #for i in moves: string += ('- ' + i + '\n')
  return string

def makeTeam(top, method='f4', amount=6):
  teamstring=''
  if method=='f4':
    f2 = makeF2(top)
    f3 = makeF3(f2)
    f4 = makeF4(f3)
    n = len(top)
    m=f3.copy()
    ix = np.unravel_index(np.random.choice(np.prod(m.shape),p=m.flatten()), m.shape)
    ix = list(ix)
    while len(ix) < amount:
      p = f4[tuple(np.random.choice(ix,3))].copy()
      p /= p.sum()
      if np.isnan(p).sum() == 0:
        i = np.random.choice(n,p=p)
        if not np.isin(i, ix):
          ix.append(i)
    for i in ix:
      poke = top.loc[str(top.index[i])]
      teamstring += '\n'+instanceOfPoke(poke)
  elif method=='f3':
    f2 = makeF2(top)
    f3 = makeF3(f2)
    n = len(top)
    m=f2.copy() # can be f2,f3 or f4
    ix = np.unravel_index(np.random.choice(np.prod(m.shape),p=m.flatten()), m.shape)
    ix = list(ix)
    while len(ix) < 6:
      p = f3[tuple(np.random.choice(ix,2))].copy()
      p /= p.sum()
      if np.isnan(p).sum() == amount:
        i = np.random.choice(n,p=p)
        if not np.isin(i, ix):
          ix.append(i)
    for i in ix:
      poke = top.loc[str(top.index[i])]
      teamstring += '\n'+instanceOfPoke(poke)
      print(instanceOfPoke(randPoke))
  elif method=='basic':
    randPoke = top.loc[np.random.choice(top.index)]
    teamstring += '\n'+instanceOfPoke(randPoke)
    friends = recommendTeammates(randPoken=amount-1)
    for friend in friends:
      teamstring += '\n'+instanceOfPoke(top.loc[friend])
  teamstring += '\n'
  return teamstring







